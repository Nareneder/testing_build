{"version":3,"file":"static/js/598.c4101946.chunk.js","mappings":"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","sources":["component/table.js","../node_modules/react-idle-timer/src/utils.js","../node_modules/react-idle-timer/src/MessageChannel/methods/broadcastChannel.js","../node_modules/react-idle-timer/src/MessageChannel/ObliviousSet.js","../node_modules/react-idle-timer/src/MessageChannel/methods/localStorage.js","../node_modules/react-idle-timer/src/MessageChannel/methods/simulate.js","../node_modules/react-idle-timer/src/MessageChannel/methodChooser.js","../node_modules/react-idle-timer/src/MessageChannel/MessageChannel.js","../node_modules/react-idle-timer/src/MessageChannel/leaderElection.js","../node_modules/react-idle-timer/src/TabManager.js","../node_modules/react-idle-timer/src/IdleTimer.js","../node_modules/react-idle-timer/src/useIdleTimer.js","Utils/IdleTimer.js","component/Dashboard.js"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\nimport { Table, Row, Col, Button } from 'react-bootstrap';\r\nimport base_url from \"../api/api\";\r\nimport DataTable from \"react-data-table-component\";\r\n\r\nwindow.Buffer = window.Buffer || require(\"buffer\").Buffer;\r\n\r\nfunction Tabledata() {\r\n  // debugger\r\n  const [userData, setUserData] = useState([]);\r\n  const [groupData, setGroupData] = useState([]);\r\n  const [subscriptionData, setSubscriptionData] = useState([]);\r\n  useEffect(() => {\r\n    getFiveUser();\r\n    getSubscription();\r\n  }, []);\r\n\r\n  const getFiveUser = async () => {\r\n    const response = await fetch(base_url + 'users/get_users_five');\r\n    const jsonData = await response.json();\r\n    setUserData(jsonData.data);\r\n    // console.log(jsonData)\r\n  };\r\n  const getSubscription = async () => {\r\n    const response = await fetch(base_url + 'groups/get_groups_five');\r\n    const jsonData = await response.json();\r\n    setGroupData(jsonData.data);\r\n    // console.log(jsonData)\r\n  };\r\n  const [pending, setPending] = useState(true);\r\n  const getFiveGroup = async () => {\r\n    const response = await fetch(base_url + 'users/get_five_subscriber');\r\n    const jsonData = await response.json();\r\n    setSubscriptionData(jsonData.data);\r\n    // console.log(jsonData)\r\n  };\r\n  useEffect(() => {\r\n    const timeout = setTimeout(() => {\r\n        getFiveUser();\r\n        getFiveGroup();\r\n        getSubscription();\r\n      setPending(false);\r\n    }, 2000);\r\n    return () => clearTimeout(timeout);\r\n  }, []);\r\n\r\n  const User_columns = [\r\n    {\r\n      id: 'user_id',\r\n      width:'60px',\r\n      name: \"Id\",\r\n      selector: (row) => row.id,\r\n      sortable: true,\r\n    },\r\n    {\r\n\r\n      name: \"Name\",\r\n      selector: (row) => row.name,\r\n      sortable: true,\r\n    },\r\n    {\r\n      name: \"Mobile\",\r\n      selector: (row) => row.country_code + ' ' + row.mobile,\r\n      sortable: true,\r\n    },\r\n    {\r\n      name: \"Status\",\r\n      selector: (row) => {\r\n        if (row.user_type === '0') {\r\n          return (\r\n            <span>Trial</span>\r\n          )\r\n        } else if (row.user_type === '1') {\r\n          return (\r\n            <span>Free</span>\r\n          )\r\n        } else if (row.user_type === '2') {\r\n          return (\r\n            <span>Premium</span>\r\n          )\r\n        }\r\n      },\r\n      sortable: true,\r\n    },\r\n    {\r\n      name: \"Creation Time\",\r\n      selector: (row) => Intl.DateTimeFormat('en-US', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }).format(row.creation_time),\r\n      sortable: true,\r\n    },\r\n  ]\r\n  const Subscription_columns = [\r\n    {\r\n      name: \"Id\",\r\n      width:'60px',\r\n      selector: (row) => row.id,\r\n      sortable: true,\r\n    },\r\n    {\r\n\r\n      name: \"Name\",\r\n      selector: (row) => row.user_name,\r\n      sortable: true,\r\n    },\r\n    {\r\n      name: \"Mobile\",\r\n      selector: (row) => row.user_country + ' ' + row.user_mobile,\r\n      sortable: true,\r\n    },\r\n    {\r\n      name: \"Device Type\",\r\n      selector: (row) => {\r\n        if (row.user_type === '0') {\r\n          return (\r\n            <span>IOS</span>\r\n          )\r\n        } else if (row.user_type === '1') {\r\n          return (\r\n            <span>Android</span>\r\n          )\r\n        }\r\n      },\r\n      sortable: true,\r\n    },\r\n    {\r\n      name: \"Creation Time\",\r\n      selector: (row) => Intl.DateTimeFormat('en-US', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }).format(row.creation_time),\r\n      sortable: true,\r\n    },\r\n  ]\r\n  const Group_columns = [\r\n    {\r\n      name: \"Id\",\r\n      width:'60px',\r\n      selector: (row) => row.id,\r\n      sortable: true,\r\n    },\r\n    {\r\n\r\n      name: \"Group Name\",\r\n      selector: (row) => row.name,\r\n      sortable: true,\r\n    },\r\n    {\r\n      name: \"Updation Time\",\r\n      selector: (row) => Intl.DateTimeFormat('en-US', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }).format(row.update_time),\r\n      sortable: true,\r\n    },\r\n    {\r\n      name: \"User Access\",\r\n      selector: (row) => {\r\n        if (row.grp_join_appr_wall === '1') {\r\n          return (\r\n            <span className=\"mb-0\">Immediate Access</span>\r\n          )\r\n        } else if (row.grp_join_appr_wall === '0') {\r\n          return (\r\n            <span className=\"mb-0\">Request Approval</span>\r\n          )\r\n        }\r\n      },\r\n      sortable: true,\r\n    },\r\n    {\r\n      name: \"Creation Time\",\r\n      selector: (row) => Intl.DateTimeFormat('en-US', { year: 'numeric', month: '2-digit', day: '2-digit' }).format(row.creation_time),\r\n      sortable: true,\r\n    },\r\n  ]\r\n\r\n  return (\r\n    // <div className={active ? 'content-mobile' : 'content'}>\r\n    <>\r\n      <Row>\r\n        <Col lg=\"6\">\r\n          <header>\r\n            <h2>5 Newly Added User</h2>\r\n          </header>\r\n          <DataTable columns={User_columns} data={userData} progressPending={pending} fixedHeader fixedHeaderScrollHeight=\"450\" />\r\n        </Col>\r\n        <Col lg=\"6\">\r\n          <header>\r\n            <h2>5 Newly Added Group</h2>\r\n          </header>\r\n          <DataTable columns={Group_columns} data={groupData} progressPending={pending} fixedHeader fixedHeaderScrollHeight=\"450\" />\r\n        </Col>\r\n      </Row>\r\n      <Row className=\"mt-5 mb-5\">\r\n        <Col lg=\"12\">\r\n          <header>\r\n            <h2>Last 5 Subscription Purchase</h2>\r\n          </header>\r\n          <DataTable columns={Subscription_columns} data={subscriptionData} progressPending={pending} paginationPosition=\"top\" fixedHeader fixedHeaderScrollHeight=\"450\" pagination />\r\n        </Col>\r\n      </Row>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Tabledata;","/**\n * Determine if we are in a browser\n * or a server environment\n * @type {Boolean}\n * @private\n */\nexport const IS_BROWSER =\n  (typeof window === 'undefined' ? 'undefined' : typeof window) === 'object'\n\n/**\n * Default element to listen for events on\n * @type {Object}\n * @private\n */\nexport const DEFAULT_ELEMENT = IS_BROWSER ? document : {}\n\n/**\n * The default events to determine activity\n * @type {Array}\n * @private\n */\nexport const DEFAULT_EVENTS = [\n  'mousemove',\n  'keydown',\n  'wheel',\n  'DOMMouseScroll',\n  'mousewheel',\n  'mousedown',\n  'touchstart',\n  'touchmove',\n  'MSPointerDown',\n  'MSPointerMove',\n  'visibilitychange'\n]\n\n/**\n * Creates a debounced function that delays invoking func until\n * after delay milliseconds has elapsed since the last time the\n * debounced function was invoked.\n * @name debounced\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n * @private\n **/\nexport function debounced (fn, delay) {\n  let timerId\n  function result (...args) {\n    if (timerId) {\n      clearTimeout(timerId)\n    }\n    timerId = setTimeout(() => {\n      fn(...args)\n      timerId = null\n    }, delay)\n  }\n\n  result.cancel = function () {\n    clearTimeout(timerId)\n  }\n\n  return result\n}\n\n/**\n * Creates a throttled function that only invokes func at most\n * once per every wait milliseconds.\n * @name throttled\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n * @private\n **/\nexport function throttled (fn, delay) {\n  let lastCall = 0\n  return function (...args) {\n    const now = new Date().getTime()\n    if (now - lastCall < delay) {\n      return\n    }\n    lastCall = now\n    return fn(...args)\n  }\n}\n\nlet lastMs = 0\nlet additional = 0\n\n/**\n * Returns current time in microseconds.\n *\n * @returns {Number} current time in microseconds\n * @private\n */\nexport function microSeconds () {\n  const ms = new Date().getTime()\n  if (ms === lastMs) {\n    additional++\n    return ms * 1000 + additional\n  } else {\n    lastMs = ms\n    additional = 0\n    return ms * 1000\n  }\n}\n\n/**\n * Generate and return a random token.\n *\n * @returns {String} Random token.\n * @private\n */\nexport function randomToken () {\n  return Math.random().toString(36).substring(2)\n}\n\n/**\n * Checks if a js object is a promise.\n *\n * @param {*} obj  Any javascript object.\n * @returns {Boolean} Wether or not this object is a promise.\n */\nexport function isPromise (obj) {\n  if (obj && typeof obj.then === 'function') {\n    /* istanbul ignore next */\n    return true\n  } else {\n    return false\n  }\n}\n\n/**\n * Sleeps for x amount of milliseconds.\n *\n * @param {Number} time   Amount of time in milliseconds.\n * @returns {Promise}\n * @private\n */\nexport function sleep (time = 0) {\n  return new Promise(resolve => setTimeout(resolve, time))\n}\n\n/**\n * Get the current timestamp.\n *\n * @returns {Number}\n * @private\n */\nexport function now () {\n  return new Date().getTime()\n}\n\n/**\n * Waits until the given function returns true\n * @param  {function}  fn\n * @return {Promise}\n */\nexport function waitUntil (fn, timeout = 0, interval = 20) {\n  let timedOut = false\n  let ok = false\n\n  /* istanbul ignore next */\n  if (timeout !== 0) {\n    sleep(timeout).then(() => {\n      timedOut = true\n    })\n  }\n\n  return new Promise((resolve, reject) => {\n    const runLoop = () => {\n      if (ok) {\n        resolve()\n        return\n      }\n      /* istanbul ignore next */\n      if (timedOut) {\n        reject(new Error(`❌ waitUntil reached timeout of ${timeout}ms`))\n        return\n      }\n      sleep(interval).then(() => {\n        ok = fn()\n        runLoop()\n      })\n    }\n    runLoop()\n  })\n}\n","/* eslint-env browser */\nimport { microSeconds } from '../../utils'\n\nexport const type = 'broadcastChannel'\n\nexport function create (channelName) {\n  const state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName)\n  }\n\n  state.bc.onmessage = msg => {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data)\n    }\n  }\n\n  return state\n}\n\nexport function close (channelState) {\n  channelState.bc.close()\n}\n\nexport function postMessage (channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false)\n    return Promise.resolve()\n  } catch (err) {\n    /* istanbul ignore next */\n    return Promise.reject(err)\n  }\n}\n\nexport function onMessage (channelState, fn) {\n  channelState.messagesCallback = fn\n}\n\nexport function canBeUsed () {\n  if (typeof BroadcastChannel === 'function') {\n    return true\n  } else {\n    /* istanbul ignore next */\n    return false\n  }\n}\n\nexport function averageResponseTime () {\n  return 150\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import { now } from '../utils'\n\nexport default class ObliviousSet {\n  constructor (ttl = 1000 * 60) {\n    this.ttl = ttl\n    this.set = new Set()\n    this.timeMap = new Map()\n  }\n\n  has (value) {\n    return this.set.has(value)\n  }\n\n  add (value) {\n    this.timeMap.set(value, now())\n    this.set.add(value)\n    this._removeTooOldValues()\n  }\n\n  clear () {\n    this.set.clear()\n    this.timeMap.clear()\n  }\n\n  _removeTooOldValues () {\n    const olderThen = now() - this.ttl\n    const iterator = this.set[Symbol.iterator]()\n\n    while (true) {\n      const value = iterator.next().value\n      if (!value) return // no more elements\n      const time = this.timeMap.get(value)\n      if (time < olderThen) {\n        this.timeMap.delete(value)\n        this.set.delete(value)\n      } else {\n        // We reached a value that is not old enough\n        return\n      }\n    }\n  }\n}\n","import ObliviousSet from '../ObliviousSet'\n\nimport {\n  randomToken,\n  microSeconds\n} from '../../utils'\n\nexport const type = 'localStorage'\n\n/**\n * Returns local storage instance\n */\nexport function getLocalStorage () {\n  let localStorage\n  if (typeof window === 'undefined') return null\n  try {\n    localStorage = window.localStorage\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage\n  } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n  return localStorage\n}\n\nexport function storageKey (channelName) {\n  return channelName\n}\n\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\nexport function postMessage (channelState, messageJson) {\n  return new Promise(resolve => {\n    const key = storageKey(channelState.channelName)\n    const writeObj = {\n      token: randomToken(),\n      time: new Date().getTime(),\n      data: messageJson,\n      uuid: channelState.uuid\n    }\n    const value = JSON.stringify(writeObj)\n    getLocalStorage().setItem(key, value)\n\n    /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n    const ev = document.createEvent('Event')\n    ev.initEvent('storage', true, true)\n    ev.key = key\n    ev.newValue = value\n    window.dispatchEvent(ev)\n\n    resolve()\n  })\n}\n\nexport function addStorageEventListener (channelName, fn) {\n  const key = storageKey(channelName)\n  const listener = ev => {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue))\n    }\n  }\n  window.addEventListener('storage', listener)\n  return listener\n}\nexport function removeStorageEventListener (listener) {\n  window.removeEventListener('storage', listener)\n}\n\nexport function create (channelName, options = {}) {\n  if (!canBeUsed()) {\n    /* istanbul ignore next */\n    throw new Error('❌ localStorage cannot be used.')\n  }\n\n  const uuid = randomToken()\n\n  /**\n     * eMIs\n     * contains all messages that have been emitted before\n     * @type {ObliviousSet}\n     */\n  const eMIs = new ObliviousSet(options.removeTimeout)\n\n  const state = {\n    channelName,\n    uuid,\n    eMIs // emittedMessagesIds\n  }\n\n  state.listener = addStorageEventListener(\n    channelName,\n    (msgObj) => {\n      if (!state.messagesCallback) return // no listener\n      if (msgObj.uuid === uuid) return // own message\n      if (!msgObj.token || eMIs.has(msgObj.token)) return // already emitted\n      if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return // too old\n\n      eMIs.add(msgObj.token)\n      state.messagesCallback(msgObj.data)\n    }\n  )\n\n  return state\n}\n\nexport function close (channelState) {\n  removeStorageEventListener(channelState.listener)\n}\n\nexport function onMessage (channelState, fn, time) {\n  channelState.messagesCallbackTime = time\n  channelState.messagesCallback = fn\n}\n\nexport function canBeUsed () {\n  const ls = getLocalStorage()\n\n  if (!ls) return false\n\n  try {\n    const key = '__check'\n    ls.setItem(key, 'works')\n    ls.removeItem(key)\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n\n    /* istanbul ignore next */\n    return false\n  }\n\n  return true\n}\n\n/* istanbul ignore next */\nexport function averageResponseTime () {\n  const defaultTime = 120\n  const userAgent = navigator.userAgent.toLowerCase()\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2\n  }\n  return defaultTime\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import { microSeconds } from '../../utils'\n\nexport const type = 'simulate'\n\nconst SIMULATE_CHANNELS = new Set()\n\nexport function create (channelName) {\n  const state = {\n    name: channelName,\n    messagesCallback: null\n  }\n  SIMULATE_CHANNELS.add(state)\n\n  return state\n}\n\nexport function close (channelState) {\n  SIMULATE_CHANNELS.delete(channelState)\n}\n\nexport function postMessage (channelState, messageJson) {\n  return new Promise(resolve => setTimeout(() => {\n    const channelArray = Array.from(SIMULATE_CHANNELS)\n    channelArray\n      .filter(channel => channel.name === channelState.name)\n      .filter(channel => channel !== channelState)\n      .filter(channel => !!channel.messagesCallback)\n      .forEach(channel => channel.messagesCallback(messageJson))\n    resolve()\n  }, 5))\n}\n\nexport function onMessage (channelState, fn) {\n  channelState.messagesCallback = fn\n}\n\n/* istanbul ignore next */\nexport function canBeUsed () {\n  return true\n}\n\n/* istanbul ignore next */\nexport function averageResponseTime () {\n  return 5\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import BroadcastChannelMethod from './methods/broadcastChannel'\nimport LocalStorageMethod from './methods/localStorage'\nimport SimulateMethod from './methods/simulate'\n\n// Order is important\nconst METHODS = [\n  BroadcastChannelMethod,\n  LocalStorageMethod\n]\n\nexport function chooseMethod (options = {}) {\n  if (options.type) {\n    // For testing\n    if (options.type === 'simulate') {\n      return SimulateMethod\n    }\n\n    // Chosen type\n    const method = METHODS.find(m => m.type === options.type)\n    if (!method) throw new Error(`❌ Method ${options.type} is not supported.`)\n    else return method\n  }\n\n  const useMethod = METHODS.find(method => method.canBeUsed())\n\n  /* istanbul ignore next */\n  if (!useMethod) {\n    throw new Error(`❌ No method found ${JSON.stringify(METHODS.map(m => m.type))}`)\n  }\n  return useMethod\n}\n","import { chooseMethod } from './methodChooser'\nimport { isPromise } from '../utils'\n\nexport class MessageChannel {\n  constructor (name, options = {}) {\n    this.name = name\n    this.options = options\n    this.method = chooseMethod(this.options)\n    this.closed = false\n\n    // isListening\n    this._isListening = false\n\n    /**\n     * _onMessageListener\n     * setting onmessage twice,\n     * will overwrite the first listener\n     */\n    this._onMessageListener = null\n\n    /**\n     * _addEventListeners\n     */\n    this._addEventListeners = {\n      message: [],\n      internal: []\n    }\n\n    /**\n     * Un send message promises\n     * where the sending is still in progress\n     * @type {Set<Promise>}\n     */\n    this._unSendMessagePromises = new Set()\n\n    /**\n     * _beforeClose\n     * array of promises that will be awaited\n     * before the channel is closed\n     */\n    this._beforeClose = []\n\n    /**\n     * _preparePromise\n     */\n    this._preparePromises = null\n    _prepareChannel(this)\n  }\n\n  postMessage (msg) {\n    if (this.closed) {\n      throw new Error(\n        '❌ Cannot post message after channel has closed'\n      )\n    }\n    return _post(this, 'message', msg)\n  }\n\n  postInternal (msg) {\n    return _post(this, 'internal', msg)\n  }\n\n  set onmessage (fn) {\n    const time = this.method.microSeconds()\n    const listenObj = {\n      time,\n      fn\n    }\n    _removeListenerObject(this, 'message', this._onMessageListener)\n    if (fn && typeof fn === 'function') {\n      this._onMessageListener = listenObj\n      _addListenerObject(this, 'message', listenObj)\n    } else {\n      /* istanbul ignore next */\n      this._onMessageListener = null\n    }\n  }\n\n  /* istanbul ignore next */\n  get onmessage () {\n    return this._onMessageListener\n  }\n\n  addEventListener (type, fn) {\n    const time = this.method.microSeconds()\n    const listenObj = {\n      time,\n      fn\n    }\n    _addListenerObject(this, type, listenObj)\n  }\n\n  removeEventListener (type, fn) {\n    const obj = this._addEventListeners[type].find(obj => obj.fn === fn)\n    _removeListenerObject(this, type, obj)\n  }\n\n  close () {\n    if (this.closed) {\n      return\n    }\n    this.closed = true\n    const awaitPrepare = this._preparePromises ? this._preparePromises : Promise.resolve()\n\n    this._onMessageListener = null\n    this._addEventListeners.message = []\n\n    return awaitPrepare\n      // Wait until all current sending are processed\n      .then(() => Promise.all(Array.from(this._unSendMessagePromises)))\n      // Run before-close hooks\n      .then(() => Promise.all(this._beforeClose.map(fn => fn())))\n      // Close the channel\n      .then(() => this.method.close(this._state))\n  }\n\n  get type () {\n    return this.method.type\n  }\n\n  isClosed () {\n    return this.closed\n  }\n}\n\nfunction _post (messageChannel, type, msg) {\n  const time = messageChannel.method.microSeconds()\n  const msgObj = {\n    time,\n    type,\n    data: msg\n  }\n\n  const awaitPrepare = messageChannel._preparePromises ? messageChannel._preparePromises : Promise.resolve()\n  return awaitPrepare.then(() => {\n    const sendPromise = messageChannel.method.postMessage(\n      messageChannel._state,\n      msgObj\n    )\n\n    // add/remove to un-send messages list\n    messageChannel._unSendMessagePromises.add(sendPromise)\n    sendPromise\n      .catch()\n      .then(() => messageChannel._unSendMessagePromises.delete(sendPromise))\n\n    return sendPromise\n  })\n}\n\nfunction _prepareChannel (channel) {\n  const maybePromise = channel.method.create(channel.name, channel.options)\n  /* istanbul ignore next */\n  if (isPromise(maybePromise)) {\n    channel._preparePromises = maybePromise\n    maybePromise.then(s => {\n      channel._state = s\n    })\n  } else {\n    channel._state = maybePromise\n  }\n}\n\nfunction _hasMessageListeners (channel) {\n  if (channel._addEventListeners.message.length > 0) return true\n  if (channel._addEventListeners.internal.length > 0) return true\n  return false\n}\n\nfunction _addListenerObject (channel, type, obj) {\n  channel._addEventListeners[type].push(obj)\n  _startListening(channel)\n}\n\nfunction _removeListenerObject (channel, type, obj) {\n  channel._addEventListeners[type] = channel._addEventListeners[type].filter(o => o !== obj)\n  _stopListening(channel)\n}\n\nfunction _startListening (channel) {\n  if (!channel._isListening && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    const listenerFn = msgObj => {\n      channel._addEventListeners[msgObj.type].forEach(obj => {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data)\n        }\n      })\n    }\n\n    const time = channel.method.microSeconds()\n    if (channel._preparePromises) {\n      /* istanbul ignore next */\n      channel._preparePromises.then(() => {\n        channel._isListening = true\n        channel.method.onMessage(\n          channel._state,\n          listenerFn,\n          time\n        )\n      })\n    } else {\n      channel._isListening = true\n      channel.method.onMessage(\n        channel._state,\n        listenerFn,\n        time\n      )\n    }\n  }\n}\n\nfunction _stopListening (channel) {\n  if (channel._isListening && !_hasMessageListeners(channel)) {\n    // no one is listening, stop subscribing\n    channel._isListening = false\n    const time = channel.method.microSeconds()\n    channel.method.onMessage(\n      channel._state,\n      null,\n      time\n    )\n  }\n}\n","import { IS_BROWSER, sleep, randomToken } from '../utils'\n\nclass LeaderElection {\n  constructor (channel, options) {\n    this._channel = channel\n    this._options = options\n\n    this.isLeader = false\n    this.isDead = false\n    this.token = randomToken()\n\n    this._isApplying = false\n    this._reApply = false\n\n    // things to clean up\n    this._unloadFns = []\n    this._listeners = []\n    this._intervals = []\n    this._duplicateListeners = () => { }\n    this._duplicateCalled = false\n    this._onBeforeDie = async () => {}\n\n    const unloadFn = async () => this.die()\n\n    if (IS_BROWSER) {\n      window.addEventListener('beforeUnload', unloadFn)\n      window.addEventListener('unload', unloadFn)\n\n      this._unloadFns.push(['beforeUnload', unloadFn])\n      this._unloadFns.push(['unload', unloadFn])\n    }\n  }\n\n  applyOnce () {\n    if (this.isLeader) return Promise.resolve(false)\n    if (this.isDead) return Promise.resolve(false)\n\n    // do nothing if already running\n    if (this._isApplying) {\n      this._reApply = true\n      return Promise.resolve(false)\n    }\n    this._isApplying = true\n\n    let stopCriteria = false\n    const received = []\n\n    const handleMessage = (msg) => {\n      if (msg.context === 'leader' && msg.token !== this.token) {\n        received.push(msg)\n\n        if (msg.action === 'apply') {\n          // Other is applying\n          if (msg.token > this.token) {\n            // Other has higher token, stop applying\n            stopCriteria = true\n          }\n        }\n\n        if (msg.action === 'tell') {\n          // Other is already leader\n          stopCriteria = true\n        }\n      }\n    }\n    this._channel.addEventListener('internal', handleMessage)\n\n    return _sendMessage(this, 'apply') // send out that this one is applying\n      .then(() => sleep(this._options.responseTime)) // let others time to respond\n      .then(() => {\n        if (stopCriteria) return Promise.reject(new Error())\n        else return _sendMessage(this, 'apply')\n      })\n      .then(() => sleep(this._options.responseTime)) // let others time to respond\n      .then(() => {\n        if (stopCriteria) return Promise.reject(new Error())\n        else return _sendMessage(this)\n      })\n      .then(() => beLeader(this)) // no one disagreed -> this one is now leader\n      .then(() => true)\n      .catch(() => false) // apply not successful\n      .then(success => {\n        this._channel.removeEventListener('internal', handleMessage)\n        this._isApplying = false\n        if (!success && this._reApply) {\n          this._reApply = false\n          return this.applyOnce()\n        } else return success\n      })\n  }\n\n  awaitLeadership () {\n    if (\n      !this._awaitLeadershipPromise\n    ) {\n      this._awaitLeadershipPromise = _awaitLeadershipOnce(this)\n    }\n    return this._awaitLeadershipPromise\n  }\n\n  set onDuplicate (fn) {\n    this._duplicateListeners = fn\n  }\n\n  /* istanbul ignore next */\n  get onDuplicate () {\n    return this._duplicateListeners\n  }\n\n  set onBeforeDie (fn) {\n    this._onBeforeDie = fn\n  }\n\n  /* istanbul ignore next */\n  get onBeforeDie () {\n    return this._onBeforeDie\n  }\n\n  async die () {\n    if (this.isDead) return\n    this.isDead = true\n\n    await this.onBeforeDie()\n    this._listeners.forEach(listener => this._channel.removeEventListener('internal', listener))\n    this._intervals.forEach(interval => clearInterval(interval))\n    this._unloadFns.forEach(uFn => {\n      if (IS_BROWSER) {\n        window.removeEventListener(uFn[0], uFn[1])\n      }\n    })\n    return _sendMessage(this, 'death')\n  }\n}\n\nfunction _awaitLeadershipOnce (leaderElector) {\n  if (leaderElector.isLeader) return Promise.resolve()\n\n  return new Promise(resolve => {\n    let resolved = false\n\n    function finish () {\n      /* istanbul ignore next */\n      if (resolved) {\n        return\n      }\n      resolved = true\n      clearInterval(interval)\n      leaderElector._channel.removeEventListener('internal', whenDeathListener)\n      resolve(true)\n    }\n\n    // try once now\n    leaderElector.applyOnce().then(() => {\n      if (leaderElector.isLeader) {\n        finish()\n      }\n    })\n\n    // try on fallbackInterval\n    const interval = setInterval(() => {\n      /* istanbul ignore next */\n      leaderElector.applyOnce().then(() => {\n        if (leaderElector.isLeader) {\n          finish()\n        }\n      })\n    }, leaderElector._options.fallbackInterval)\n    leaderElector._intervals.push(interval)\n\n    // try when other leader dies\n    const whenDeathListener = msg => {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector.applyOnce().then(() => {\n          if (leaderElector.isLeader) finish()\n        })\n      }\n    }\n    leaderElector._channel.addEventListener('internal', whenDeathListener)\n    leaderElector._listeners.push(whenDeathListener)\n  })\n}\n\n/**\n * Sends and internal message over the broadcast-channel\n */\nfunction _sendMessage (leaderElector, action) {\n  const msgJson = {\n    context: 'leader',\n    action,\n    token: leaderElector.token\n  }\n  return leaderElector._channel.postInternal(msgJson)\n}\n\nexport function beLeader (leaderElector) {\n  leaderElector.isLeader = true\n\n  const isLeaderListener = msg => {\n    if (msg.context === 'leader' && msg.action === 'apply') {\n      _sendMessage(leaderElector, 'tell')\n    }\n\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._duplicateCalled) {\n      /**\n       * Another instance is also leader!\n       * This can happen on rare events\n       * like when the CPU is at 100% for long time\n       * or the tabs are open very long and the browser throttles them.\n       */\n      leaderElector._duplicateCalled = true\n      leaderElector._duplicateListeners() // message the lib user so the app can handle the problem\n      _sendMessage(leaderElector, 'tell') // ensure other leader also knows the problem\n    }\n  }\n  leaderElector._channel.addEventListener('internal', isLeaderListener)\n  leaderElector._listeners.push(isLeaderListener)\n  return _sendMessage(leaderElector, 'tell')\n}\n\nexport function createLeaderElection (channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('❌ MessageChannel already has a leader-elector')\n  }\n\n  const elector = new LeaderElection(channel, options)\n  channel._beforeClose.push(async () => elector.die())\n\n  channel._leaderElector = elector\n  return elector\n}\n","import { MessageChannel, createLeaderElection } from './MessageChannel'\nexport const TabManager = ({\n  type,\n  channelName,\n  fallbackInterval,\n  responseTime,\n  emitOnAllTabs,\n  callbacks,\n  start,\n  reset,\n  pause,\n  resume\n}) => {\n  const channel = new MessageChannel(channelName, { type })\n  const elector = createLeaderElection(channel, { fallbackInterval, responseTime })\n  const registry = {}\n\n  // Register self\n  registry[elector.token] = false\n\n  let leader = false\n  let allIdle = true\n\n  const isLeader = () => leader\n\n  elector.awaitLeadership().then(() => {\n    leader = true\n  })\n\n  channel.addEventListener('message', ([type, id]) => {\n    switch (type) {\n      case 'register':\n        registry[id] = false\n        break\n      case 'deregister':\n        delete registry[id]\n        break\n      case 'idle':\n        idle(id)\n        break\n      case 'active':\n        active(id)\n        break\n      case 'emitIdle':\n        callbacks.onIdle()\n        break\n      case 'emitActive':\n        callbacks.onActive()\n        break\n      case 'start':\n        start(true)\n        break\n      case 'reset':\n        reset(true)\n        break\n      case 'pause':\n        pause(true)\n        break\n      case 'resume':\n        resume(true)\n        break\n      default:\n        // no op\n    }\n  })\n\n  const setAllIdle = bool => {\n    allIdle = bool\n  }\n\n  const isAllIdle = () => allIdle\n\n  const idle = (id = elector.token) => {\n    registry[id] = true\n    const isIdle = Object.values(registry).every(v => v)\n    if (!allIdle && isIdle) {\n      allIdle = true\n      if (isLeader()) {\n        callbacks.onIdle()\n        if (emitOnAllTabs) send('emitIdle')\n      } else {\n        send('idle')\n      }\n    }\n  }\n\n  const active = (id = elector.token) => {\n    registry[id] = false\n    const isActive = Object.values(registry).some(v => !v)\n    if (allIdle && isActive) {\n      allIdle = false\n      if (isLeader()) {\n        callbacks.onActive()\n        if (emitOnAllTabs) send('emitActive')\n      } else {\n        send('active')\n      }\n    }\n  }\n\n  /* istanbul ignore next */\n  elector.onDuplicate = async () => await elector.die()\n  elector.onBeforeDie = async () => await send('deregister')\n\n  const send = async message => channel.postMessage([message, elector.token])\n\n  const close = async () => {\n    await elector.die()\n    await channel.close()\n  }\n\n  // Register self with remote tabs\n  send('register')\n\n  return { close, send, isLeader, idle, active, isAllIdle, setAllIdle }\n}\n","/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name IdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { TabManager } from './TabManager'\nimport { IS_BROWSER, DEFAULT_ELEMENT, DEFAULT_EVENTS, debounced, throttled } from './utils'\n\n/**\n * Detects when your user is idle\n * @class IdleTimer\n * @private\n */\nclass IdleTimer extends Component {\n  /**\n   * Creates an instance of IdleTimer\n   * bind all of our internal events here\n   * for best performance\n   * @param {Object} props\n   * @return {IdleTimer}\n   * @private\n   */\n  constructor (props) {\n    super(props)\n\n    /**\n     * Sets initial component state\n     * @type {Object}\n     * @private\n     */\n    this.state = {\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      lastIdle: null,\n      idleTime: 0,\n      remaining: null,\n      pageX: null,\n      pageY: null\n    }\n\n    /**\n     * The timer instance\n     * @type {Timeout}\n     * @private\n     */\n    this.tId = null\n\n    /**\n     * Wether or not events are bound\n     * @type {boolean}\n     * @private\n     */\n    this.eventsBound = false\n\n    this.callbackRefs = {}\n\n    // Debounce and throttle can't both be set\n    if (props.debounce > 0 && props.throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Create debounced action if applicable\n    if (props.debounce > 0) {\n      this._onAction = debounced(props.onAction, props.debounce)\n\n    // Create throttled action if applicable\n    } else if (props.throttle > 0) {\n      this._onAction = throttled(props.onAction, props.throttle)\n\n    // Set custom onAction\n    } else {\n      this._onAction = props.onAction\n    }\n\n    // Create a throttle event handler if applicable\n    if (props.eventsThrottle > 0) {\n      this.handleEvent = throttled(this._handleEvent.bind(this), props.eventsThrottle)\n    } else {\n      this.handleEvent = this._handleEvent.bind(this)\n    }\n\n    // If startOnMount is set, idle state defaults to true\n    if (!props.startOnMount || props.startManually) {\n      this.state.idle = true\n    }\n\n    // Bind all events to component scope, built for speed 🚀\n    this._toggleIdleState = this._toggleIdleState.bind(this)\n    this.start = this.start.bind(this)\n    this.reset = this.reset.bind(this)\n    this.pause = this.pause.bind(this)\n    this.resume = this.resume.bind(this)\n    this.isIdle = this.isIdle.bind(this)\n    this.getRemainingTime = this.getRemainingTime.bind(this)\n    this.getElapsedTime = this.getElapsedTime.bind(this)\n    this.getLastActiveTime = this.getLastActiveTime.bind(this)\n    this.getLastIdleTime = this.getLastIdleTime.bind(this)\n    this.getTotalIdleTime = this.getTotalIdleTime.bind(this)\n    this.getTotalActiveTime = this.getTotalActiveTime.bind(this)\n  }\n\n  /**\n   * Runs once the component has mounted\n   * here we handle automatically starting\n   * the idletimer\n   * @private\n   */\n  componentDidMount () {\n    const { startOnMount, startManually } = this.props\n\n    // Set up cross tab\n    this._setupTabManager()\n\n    if (startManually) return\n    if (startOnMount) {\n      this.start()\n    } else {\n      this._bindEvents()\n    }\n  }\n\n  componentDidUpdate (prevProps) {\n    // Update debounce function\n    if ((prevProps.debounce !== this.props.debounce) && this.props.debounce > 0) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = debounced(this.props.onAction, this.props.debounce)\n    } else\n    // Update throttle function\n    if ((prevProps.throttle !== this.props.throttle) && this.props.throttle > 0) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = throttled(this.props.onAction, this.props.throttle)\n    } else\n    // Remove throttle or debounce\n    if (\n      (prevProps.throttle && this.props.throttle === 0) ||\n      (prevProps.debounce && this.props.debounce === 0)\n    ) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = this.props.onAction\n    }\n\n    // Update event throttle function\n    if (prevProps.eventsThrottle !== this.props.eventsThrottle) {\n      this._unbindEvents()\n      this.handleEvent = throttled(this._handleEvent.bind(this), this.props.eventsThrottle)\n      this._bindEvents()\n    }\n    // Update timeout value\n    if (prevProps.timeout !== this.props.timeout) {\n      if (this.state.idle) this.reset()\n    }\n\n    // Update callback refs\n    if (prevProps.onActive !== this.props.onActive) this.callbackRefs.onActive = this.props.onActive\n    if (prevProps.onIdle !== this.props.onIdle) this.callbackRefs.onIdle = this.props.onIdle\n  }\n\n  /**\n   * Called before the component un-mounts\n   * here we clear the timer and remove\n   * all the event listeners\n   * @private\n   */\n  componentWillUnmount () {\n    // Clear timeout to prevent delayed state changes\n    clearTimeout(this.tId)\n    this._unbindEvents(true)\n    // Cancel any debounced onAction handlers\n    if (this._onAction.cancel) this._onAction.cancel()\n    /* istanbul ignore next */\n    if (this.manager) {\n      this.manager.close().catch(console.error)\n    }\n  }\n\n  /**\n   * Render children if IdleTimer is used as a wrapper\n   * @return {Component} children\n   * @private\n   */\n  render () {\n    const { children } = this.props\n    return children || null\n  }\n\n  /**\n   * Setup the Tab Manager.\n   * @private\n   */\n  _setupTabManager () {\n    const { crossTab, onIdle, onActive } = this.props\n    this.callbackRefs = { onIdle, onActive }\n\n    /* istanbul ignore next */\n    if (crossTab) {\n      const {\n        type,\n        channelName,\n        fallbackInterval,\n        responseTime,\n        emitOnAllTabs\n      } = Object.assign({\n        channelName: 'idle-timer',\n        fallbackInterval: 2000,\n        responseTime: 100,\n        removeTimeout: 1000 * 60,\n        emitOnAllTabs: false\n      }, crossTab === true ? {} : crossTab)\n\n      this.manager = TabManager({\n        type,\n        channelName,\n        fallbackInterval,\n        responseTime,\n        emitOnAllTabs,\n        callbacks: this.callbackRefs,\n        start: this.start,\n        reset: this.reset,\n        pause: this.pause,\n        resume: this.resume\n      })\n    }\n  }\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  _bindEvents () {\n    // Don't bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    const { element, events, passive, capture } = this.props\n    if (!this.eventsBound) {\n      events.forEach(e => {\n        element.addEventListener(e, this.handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.eventsBound = true\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  _unbindEvents (force = false) {\n    // If we are not in a browser\n    // we don't need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    const { element, events, passive, capture } = this.props\n    if (this.eventsBound || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, this.handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.eventsBound = false\n    }\n  }\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  _toggleIdleState (e) {\n    // Fire the appropriate action\n    // and pass the event through\n    // Toggle the idle state\n    this.setState((prevState) => ({\n      idle: !prevState.idle,\n      lastIdle: !prevState.idle ? (+new Date()) - this.props.timeout : prevState.lastIdle,\n      idleTime: prevState.idle ? prevState.idleTime + (+new Date()) - prevState.lastIdle : prevState.idleTime\n    }), () => {\n      const { onActive, onIdle, stopOnIdle } = this.props\n      const { idle } = this.state\n      if (idle) {\n        if (stopOnIdle) {\n          // Clear any existing timeout\n          clearTimeout(this.tId)\n          this.tId = null\n          // Unbind events\n          this._unbindEvents()\n        }\n\n        if (this.manager) {\n          /* istanbul ignore next */\n          this.manager.idle()\n        } else {\n          onIdle(e)\n        }\n      } else {\n        this._bindEvents()\n        if (this.manager) {\n          /* istanbul ignore next */\n          this.manager.active()\n        } else {\n          onActive(e)\n        }\n      }\n    })\n  }\n\n  /**\n   * Event handler for supported event types\n   * @param  {Object} e event object\n   * @private\n   */\n  _handleEvent (e) {\n    const { remaining, pageX, pageY, idle } = this.state\n    const { timeout, stopOnIdle } = this.props\n\n    // Fire onAction event\n    this._onAction(e)\n\n    // Already active, ignore events\n    if (remaining) return\n\n    // Mousemove event\n    if (e.type === 'mousemove') {\n      // If coords are same, it didn't move\n      /* istanbul ignore next */\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coords don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      /* istanbul ignore next */\n      const elapsed = this.getElapsedTime()\n      /* istanbul ignore next */\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Determine last time User was active, as can't rely on setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = +new Date() - this.getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if ((idle && !stopOnIdle) || (!idle && elapsedTimeSinceLastActive > timeout)) {\n      this._toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    this.setState({\n      lastActive: +new Date(),\n      pageX: e.pageX,\n      pageY: e.pageY\n    })\n\n    // If the user is idle and stopOnIdle flag is not set\n    // set a new timeout\n    if (idle) {\n      if (!stopOnIdle) {\n        this.tId = setTimeout(this._toggleIdleState, timeout)\n      }\n    } else {\n      this.tId = setTimeout(this._toggleIdleState, timeout)\n    }\n  }\n\n  /**\n   * Set initial state and start timer\n   * @name start\n   */\n  start (remote = true) {\n    // Clear timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Bind the events\n    this._bindEvents()\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null\n    })\n\n    if (this.manager) {\n      /* istanbul ignore next */\n      this.manager.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('start')\n      }\n    }\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = setTimeout(this._toggleIdleState, timeout)\n  }\n\n  /**\n   * Restore initial state and restart timer, calling onActive\n   * @name reset\n   */\n  reset (remote = false) {\n    // Clear timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Bind the events\n    this._bindEvents()\n\n    if (this.state.idle) {\n      if (this.manager) {\n        /* istanbul ignore next */\n        this.manager.active()\n      } else {\n        this.props.onActive()\n      }\n    }\n\n    if (this.manager) {\n      /* istanbul ignore next */\n      this.manager.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('reset')\n      }\n    }\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null\n    })\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = setTimeout(this._toggleIdleState, timeout)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  pause (remote = false) {\n    // Timer is already paused\n    const { remaining } = this.state\n    if (remaining !== null) return\n\n    // Unbind events\n    this._unbindEvents()\n\n    // Clear existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Send event to other tabs\n    if (this.manager) {\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('pause')\n      }\n    }\n\n    // Define how much is left on the timer\n    this.setState({\n      remaining: this.getRemainingTime()\n    })\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  resume (remote = false) {\n    // Timer is not paused\n    const { remaining, idle } = this.state\n    if (remaining === null) return\n\n    // Bind events\n    this._bindEvents()\n\n    // Send event to other tabs\n    if (this.manager) {\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('resume')\n      }\n    }\n\n    // Start timer and clear remaining\n    // if we are in the active state\n    if (!idle) {\n      // Set a new timeout\n      this.tId = setTimeout(this._toggleIdleState, remaining)\n      // Set new state\n      this.setState({ remaining: null, lastActive: +new Date() })\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {number} Milliseconds remaining\n   */\n  getRemainingTime () {\n    const { remaining, lastActive } = this.state\n    const { timeout } = this.props\n\n    // If idle there is no time remaining\n    if (remaining !== null) {\n      return remaining < 0 ? 0 : remaining\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const timeLeft = timeout - ((+new Date()) - lastActive)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  getElapsedTime () {\n    const { oldDate } = this.state\n    return (+new Date()) - oldDate\n  }\n\n  /**\n   * Last time the user was idle\n   * @name getLastIdleTime\n   * @return {Timestamp}\n   */\n  getLastIdleTime () {\n    const { lastIdle } = this.state\n    return lastIdle\n  }\n\n  /**\n   * Total time the user was idle\n   * @name getTotalIdleTime\n   * @return {number}\n   */\n  getTotalIdleTime () {\n    const { idle, lastIdle, idleTime } = this.state\n    if (idle) {\n      return ((+new Date()) - lastIdle) + idleTime\n    } else {\n      return idleTime\n    }\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  getLastActiveTime () {\n    const { lastActive } = this.state\n    return lastActive\n  }\n\n  /**\n   * Total time the user was active\n   * @name getTotalActiveTime\n   * @return {number}\n   */\n  getTotalActiveTime () {\n    return this.getElapsedTime() - this.getTotalIdleTime()\n  }\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {boolean}\n   */\n  isIdle () {\n    const { idle } = this.state\n    return idle\n  }\n\n  /**\n   * Returns wether or not this is the leader tab\n   * @name isLeader\n   * @return {boolean}\n   */\n  isLeader () {\n    return this.manager ? this.manager.isLeader() : true\n  }\n}\n\n/**\n * Type checks for every property\n * @type {Object}\n * @private\n */\nIdleTimer.propTypes = {\n  /**\n   * Activity Timeout in milliseconds\n   * default: 1200000\n   * @type {Number}\n   */\n  timeout: PropTypes.number,\n  /**\n   * DOM events to listen to\n   * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n   * @type {Array}\n   */\n  events: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * Function to call when user is idle\n   * default: () => {}\n   * @type {Function}\n   */\n  onIdle: PropTypes.func,\n  /**\n   * Function to call when user becomes active\n   * default: () => {}\n   * @type {Function}\n   */\n  onActive: PropTypes.func,\n  /**\n   * Function to call on user actions\n   * default: () => {}\n   * @type {Function}\n   */\n  onAction: PropTypes.func,\n  /**\n   * Debounce the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {Number}\n   */\n  debounce: PropTypes.number,\n  /**\n   * Throttle the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {Number}\n   */\n  throttle: PropTypes.number,\n  /**\n   * Throttle the event handler function by setting delay in milliseconds\n   * default: 200\n   * @type {Number}\n   */\n  eventsThrottle: PropTypes.number,\n  /**\n   * Element reference to bind activity listeners to\n   * default: document\n   * @type {Object}\n   */\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  /**\n   * Start the timer on mount\n   * default: true\n   * @type {Boolean}\n   */\n  startOnMount: PropTypes.bool,\n  /**\n   * Require the timer to be started manually.\n   * default: false\n   * @type {Boolean}\n   */\n  startManually: PropTypes.bool,\n  /**\n   * Once the user goes idle the IdleTimer will not\n   * reset on user input instead, reset() must be\n   * called manually to restart the timer\n   * default: false\n   * @type {Boolean}\n   */\n  stopOnIdle: PropTypes.bool,\n  /**\n   * Bind events passively\n   * default: true\n   * @type {Boolean}\n   */\n  passive: PropTypes.bool,\n  /**\n   * Capture events\n   * default: true\n   * @type {Boolean}\n   */\n  capture: PropTypes.bool,\n  /**\n   * Cross Tab functionality.\n   * default: false\n   * @type {Boolean|Object}\n   */\n  crossTab: PropTypes.oneOfType([\n    PropTypes.bool,\n    PropTypes.shape({\n      type: PropTypes.oneOf(['broadcastChannel', 'localStorage', 'simulate']),\n      channelName: PropTypes.string,\n      fallbackInterval: PropTypes.number,\n      responseTime: PropTypes.number,\n      removeTimeout: PropTypes.number,\n      emitOnAllTabs: PropTypes.bool\n    })\n  ])\n}\n\n/**\n * Sets default property values\n * @type {Object}\n * @private\n */\nIdleTimer.defaultProps = {\n  timeout: 1000 * 60 * 20,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: () => { },\n  onActive: () => { },\n  onAction: () => { },\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: true,\n  startManually: false,\n  stopOnIdle: false,\n  capture: true,\n  passive: true,\n  crossTab: false\n}\n\nexport default IdleTimer\n","/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name useIdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { useEffect, useRef, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { TabManager } from './TabManager'\nimport { IS_BROWSER, DEFAULT_ELEMENT, DEFAULT_EVENTS, debounced, throttled } from './utils'\n\n/**\n * Detects when your user is idle\n * @function useIdleTimer\n * @private\n */\nfunction useIdleTimer ({\n  timeout = 1000 * 60 * 20,\n  element = DEFAULT_ELEMENT,\n  events = DEFAULT_EVENTS,\n  onIdle = () => { },\n  onActive = () => { },\n  onAction = () => { },\n  debounce = 0,\n  throttle = 0,\n  eventsThrottle = 200,\n  startOnMount = true,\n  startManually = false,\n  stopOnIdle = false,\n  capture = true,\n  passive = true,\n  crossTab = false\n} = {}) {\n  const eventsBound = useRef(false)\n  const idle = useRef(true)\n  const oldDate = useRef(+new Date())\n  const remaining = useRef(null)\n  const pageX = useRef(null)\n  const pageY = useRef(null)\n  const tId = useRef(null)\n  const lastActive = useRef(null)\n  const lastIdle = useRef(null)\n  const idleTime = useRef(0)\n  const firstLoad = useRef(true)\n  const _timeout = useRef(timeout)\n  const manager = useRef(null)\n\n  /* istanbul ignore next */\n  if (crossTab) {\n    if (crossTab === true) crossTab = {}\n    crossTab = Object.assign({\n      channelName: 'idle-timer',\n      fallbackInterval: 2000,\n      responseTime: 100,\n      removeTimeout: 1000 * 60,\n      emitOnAllTabs: false\n    }, crossTab)\n  }\n\n  // Event emitters\n  const emitOnIdle = useRef(onIdle)\n  const emitOnActive = useRef(onActive)\n  const emitOnAction = useRef(onAction)\n\n  useEffect(() => {\n    emitOnIdle.current = onIdle\n  }, [onIdle])\n\n  useEffect(() => {\n    emitOnActive.current = onActive\n  }, [onActive])\n\n  useEffect(() => {\n    emitOnAction.current = onAction\n  }, [onAction])\n\n  const intermediateOnAction = useMemo(() => {\n    function callOnAction (e) {\n      emitOnAction.current(e)\n    }\n\n    // Cancel any existing debounce timeouts\n    if (callOnAction.cancel) callOnAction.cancel()\n\n    // Create debounced action if applicable\n    if (debounce > 0) {\n      return debounced(callOnAction, debounce)\n\n      // Create throttled action if applicable\n    } else if (throttle > 0) {\n      return throttled(callOnAction, throttle)\n\n      // No throttle or debounce\n    } else {\n      return callOnAction\n    }\n  }, [throttle, debounce])\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  const _toggleIdleState = e => {\n    const nextIdle = !idle.current\n    idle.current = nextIdle\n    if (nextIdle) {\n      if (stopOnIdle) {\n        // Clear any existing timeout\n        clearTimeout(tId.current)\n        tId.current = null\n        // Unbind events\n        _unbindEvents()\n      }\n      lastIdle.current = (+new Date()) - _timeout.current\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.idle()\n      } else {\n        emitOnIdle.current(e)\n      }\n    } else {\n      idleTime.current += (+new Date()) - lastIdle.current\n      _bindEvents()\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.active()\n      } else {\n        emitOnActive.current(e)\n      }\n    }\n  }\n\n  /**\n   * Event handler\n   * @param {Event} e\n   */\n  const _handleEvent = e => {\n    // Fire onAction event\n    intermediateOnAction(e)\n\n    // Already active, ignore events\n    if (remaining.current) return\n\n    // Mousemove event\n    /* istanbul ignore next */\n    if (e.type === 'mousemove') {\n      // If coords are same, it didn't move\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coords don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      const elapsed = getElapsedTime()\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Determine last time User was active, as can't rely on setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = +new Date() - getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if (\n      (idle.current && !stopOnIdle) ||\n      (!idle.current && elapsedTimeSinceLastActive > _timeout.current)\n    ) {\n      _toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    lastActive.current = +new Date()\n    pageX.current = e.pageX\n    pageY.current = e.pageY\n\n    // If the user is active, set a new timeout\n    if (!idle.current) {\n      tId.current = setTimeout(_toggleIdleState, _timeout.current)\n    }\n  }\n\n  /**\n   * Reference to current handleEvent function.\n   * @private\n   */\n  const handleEvent = useRef(_handleEvent)\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  const _bindEvents = () => {\n    // Don't bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    if (!eventsBound.current) {\n      events.forEach(e => {\n        element.addEventListener(e, handleEvent.current, {\n          capture,\n          passive\n        })\n      })\n      eventsBound.current = true\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  const _unbindEvents = (force = false) => {\n    // If we are not in a browser\n    // we don't need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    if (eventsBound.current || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, handleEvent.current, {\n          capture,\n          passive\n        })\n      })\n      eventsBound.current = false\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {number} Milliseconds remaining\n   */\n  const getRemainingTime = () => {\n    // If idle there is no time remaining\n    if (remaining.current !== null) {\n      return remaining.current < 0 ? 0 : remaining.current\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const timeLeft = _timeout.current - ((+new Date()) - lastActive.current)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  const getElapsedTime = () => (+new Date()) - oldDate.current\n\n  /**\n   * Last time the user was idle\n   * @name getLastIdleTime\n   * @return {Timestamp}\n   */\n  const getLastIdleTime = () => lastIdle.current\n\n  /**\n   * Get the total time user is idle\n   * @name getTotalIdleTime\n   * @return {number} Milliseconds idle\n   */\n  const getTotalIdleTime = () => {\n    if (idle.current) {\n      return ((+new Date()) - lastIdle.current) + idleTime.current\n    } else {\n      return idleTime.current\n    }\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  const getLastActiveTime = () => lastActive.current\n\n  /**\n   * Get the total time user is active\n   * @name getTotalActiveTime\n   * @return {number} Milliseconds active\n   */\n  const getTotalActiveTime = () => getElapsedTime() - getTotalIdleTime()\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {Boolean}\n   */\n  const isIdle = () => idle.current\n\n  /**\n   * Returns wether or not this is the leader tab\n   * @returns {Boolean}\n   */\n  const isLeader = () => manager.current ? manager.current.isLeader() : true\n\n  /**\n  * Set initial state and start timer\n  * @name reset\n  */\n  const start = (remote = false) => {\n    // Clear timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Bind the events\n    _bindEvents()\n\n    // Set state\n    idle.current = false\n    oldDate.current = +new Date()\n    lastActive.current = +new Date()\n    remaining.current = null\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      manager.current.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('start')\n      }\n    }\n\n    // Set new timeout\n    tId.current = setTimeout(_toggleIdleState, _timeout.current)\n  }\n\n  /**\n  * Restore initial state and restart timer, calling onActive\n  * @name reset\n  */\n  const reset = (remote = false) => {\n    // Clear timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Bind the events\n    _bindEvents()\n\n    // Emit active\n    if (idle.current) {\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.active()\n      } else {\n        emitOnActive.current()\n      }\n    }\n\n    // Reset state\n    idle.current = false\n    oldDate.current = +new Date()\n    lastActive.current = +new Date()\n    remaining.current = null\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      manager.current.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('reset')\n      }\n    }\n\n    // Set new timeout\n    tId.current = setTimeout(_toggleIdleState, _timeout.current)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  const pause = (remote = false) => {\n    // Timer is already paused\n    if (remaining.current !== null) return\n\n    // Unbind events\n    _unbindEvents()\n\n    // Clear existing timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Define how much is left on the timer\n    remaining.current = getRemainingTime()\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('pause')\n      }\n    }\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  const resume = (remote = false) => {\n    // Timer is not paused\n    if (remaining.current === null) return\n\n    // Bind events\n    _bindEvents()\n\n    // Start timer and clear remaining\n    // if we are in the idle state\n    if (!idle.current) {\n      // Set a new timeout\n      tId.current = setTimeout(_toggleIdleState, remaining.current)\n      // Set states\n      remaining.current = null\n      lastActive.current = +new Date()\n    }\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('resume')\n      }\n    }\n  }\n\n  /**\n   * Hook lifecycle\n   */\n  useEffect(() => {\n    // Debounce and throttle can't both be set\n    if (debounce > 0 && throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Set up cross tab\n    /* istanbul ignore next */\n    if (crossTab) {\n      manager.current = TabManager({\n        type: crossTab.type,\n        channelName: crossTab.channelName,\n        fallbackInterval: crossTab.fallbackInterval,\n        responseTime: crossTab.responseTime,\n        emitOnAllTabs: crossTab.emitOnAllTabs,\n        callbacks: {\n          onIdle: emitOnIdle.current,\n          onActive: emitOnActive.current\n        },\n        start,\n        reset,\n        pause,\n        resume\n      })\n    }\n\n    // If startOnMount is enabled, start the timer\n    if (startManually) {\n      return async () => {\n        clearTimeout(tId.current)\n        _unbindEvents(true)\n        if (crossTab) await manager.current.close()\n      }\n    }\n\n    if (startOnMount) {\n      start()\n    } else {\n      _bindEvents()\n    }\n\n    // Clear and unbind on unmount\n    return async () => {\n      clearTimeout(tId.current)\n      _unbindEvents(true)\n      if (intermediateOnAction.cancel) intermediateOnAction.cancel()\n      if (crossTab) await manager.current.close()\n    }\n  }, [])\n\n  useEffect(() => {\n    const eventsWereBound = eventsBound.current\n    if (eventsWereBound) _unbindEvents()\n    if (eventsThrottle > 0) {\n      handleEvent.current = throttled(_handleEvent, eventsThrottle)\n    } else {\n      handleEvent.current = _handleEvent\n    }\n    if (eventsWereBound) _bindEvents()\n  }, [eventsThrottle])\n\n  useEffect(() => {\n    _timeout.current = timeout\n    if (!firstLoad.current && idle.current) {\n      reset()\n    }\n    firstLoad.current = false\n  }, [timeout])\n\n  return {\n    isIdle,\n    isLeader,\n    start,\n    pause,\n    reset,\n    resume,\n    getLastIdleTime,\n    getTotalIdleTime,\n    getLastActiveTime,\n    getTotalActiveTime,\n    getElapsedTime,\n    getRemainingTime\n  }\n}\n\n/**\n * Type checks for every property\n * @type {Object}\n * @private\n */\nuseIdleTimer.propTypes = {\n  /**\n   * Activity Timeout in milliseconds\n   * default: 1200000\n   * @type {number}\n   */\n  timeout: PropTypes.number,\n  /**\n   * DOM events to listen to\n   * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n   * @type {Array}\n   */\n  events: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * Function to call when user is idle.\n   * default: () => {}\n   * @type {Function}\n   */\n  onIdle: PropTypes.func,\n  /**\n   * Function to call when user becomes active.\n   * default: () => {}\n   * @type {Function}\n   */\n  onActive: PropTypes.func,\n  /**\n   * Function to call on user actions.\n   * default: () => {}\n   * @type {Function}\n   */\n  onAction: PropTypes.func,\n  /**\n   * Debounce the onAction function by setting delay in milliseconds.\n   * default: 0\n   * @type {number}\n   */\n  debounce: PropTypes.number,\n  /**\n   * Throttle the onAction function by setting delay in milliseconds.\n   * default: 0\n   * @type {number}\n   */\n  throttle: PropTypes.number,\n  /**\n   * Throttle the event handler function by setting delay in milliseconds.\n   * default: 200\n   * @type {number}\n   */\n  eventsThrottle: PropTypes.number,\n  /**\n   * Element reference to bind activity listeners to.\n   * default: document\n   * @type {Object}\n   */\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  /**\n   * Start the timer on mount.\n   * default: true\n   * @type {Boolean}\n   */\n  startOnMount: PropTypes.bool,\n  /**\n   * Require the timer to be started manually.\n   * default: false\n   * @type {Boolean}\n   */\n  startManually: PropTypes.bool,\n  /**\n   * Once the user goes idle the IdleTimer will not\n   * reset on user input instead, start() or reset() must be\n   * called manually to restart the timer.\n   * default: false\n   * @type {Boolean}\n   */\n  stopOnIdle: PropTypes.bool,\n  /**\n   * Bind events passively.\n   * default: true\n   * @type {Boolean}\n   */\n  passive: PropTypes.bool,\n  /**\n   * Capture events.\n   * default: true\n   * @type {Boolean}\n   */\n  capture: PropTypes.bool,\n  /**\n   * Cross Tab functionality.\n   * default: false\n   * @type {Boolean|Object}\n   */\n  crossTab: PropTypes.oneOfType([\n    PropTypes.bool,\n    PropTypes.shape({\n      type: PropTypes.oneOf(['broadcastChannel', 'localStorage', 'simulate']),\n      channelName: PropTypes.string,\n      fallbackInterval: PropTypes.number,\n      responseTime: PropTypes.number,\n      removeTimeout: PropTypes.number,\n      emitOnAllTabs: PropTypes.bool\n    })\n  ])\n}\n\n/**\n * Sets default property values\n * @type {Object}\n * @private\n */\nuseIdleTimer.defaultProps = {\n  timeout: 1000 * 60 * 20,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: () => { },\n  onActive: () => { },\n  onAction: () => { },\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: true,\n  startManually: false,\n  stopOnIdle: false,\n  capture: true,\n  passive: true,\n  crossTab: false\n}\n\nexport default useIdleTimer\n","import React, { useRef } from 'react';\r\nimport IdleTimer from 'react-idle-timer';\r\nimport { useNavigate } from \"react-router-dom\";\r\n\r\nexport default function UseridleTimer(){\r\n    const history = useNavigate();\r\n    const IdleTimerRef = useRef(null)\r\n    const onIdle =()=>{\r\n        sessionStorage.clear();\r\n        if(sessionStorage.length === 0){\r\n            history('/')\r\n        }\r\n    }\r\n    return(\r\n        <>\r\n            <IdleTimer ref={IdleTimerRef} timeout={60*60*1000} onIdle={onIdle}></IdleTimer>\r\n        </>\r\n    )\r\n}","import { Col, Container, Dropdown, Row } from \"react-bootstrap\";\r\nimport { NavLink, useNavigate } from \"react-router-dom\";\r\nimport Tabledata from \"./table\";\r\nimport UseridleTimer from '../Utils/IdleTimer';\r\nimport Sidebar from \"./Sidebar\";\r\nimport { useSelector } from \"react-redux\";\r\n\r\nconst Dashboard = () => {\r\n\r\n    \r\n\r\n    const active = useSelector((state) => state.toggleSidebar.active);\r\n    return (\r\n        <div className=\"main-content\">\r\n            <Sidebar />\r\n            <UseridleTimer></UseridleTimer>\r\n            <div className={active ? 'content-mobile' : 'content'}>\r\n                <Container fluid>\r\n                    <Tabledata />\r\n                </Container>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Dashboard;"],"names":["window","Buffer","require","useState","userData","setUserData","groupData","setGroupData","subscriptionData","setSubscriptionData","useEffect","getFiveUser","getSubscription","fetch","base_url","response","json","jsonData","data","pending","setPending","getFiveGroup","timeout","setTimeout","clearTimeout","User_columns","id","width","name","selector","row","sortable","country_code","mobile","user_type","Intl","DateTimeFormat","year","month","day","hour","minute","second","format","creation_time","Subscription_columns","user_name","user_country","user_mobile","Group_columns","update_time","grp_join_appr_wall","className","Row","Col","lg","columns","progressPending","fixedHeader","fixedHeaderScrollHeight","paginationPosition","pagination","IS_BROWSER","p","DEFAULT_ELEMENT","document","DEFAULT_EVENTS","debounced","fn","delay","timerId","result","args","cancel","throttled","lastCall","now","Date","getTime","lastMs","additional","microSeconds","ms","randomToken","Math","random","toString","substring","sleep","time","Promise","resolve","create","channelName","state","messagesCallback","bc","BroadcastChannel","onmessage","msg","close","channelState","onMessage","postMessage","messageJson","err","reject","canBeUsed","type","averageResponseTime","ObliviousSet","ttl","e","set","Set","timeMap","Map","value","this","has","add","_removeTooOldValues","clear","olderThen","iterator","Symbol","next","get","getLocalStorage","localStorage","addStorageEventListener","key","listener","ev","JSON","parse","newValue","addEventListener","ls","setItem","removeItem","options","Error","uuid","eMIs","removeTimeout","msgObj","token","messagesCallbackTime","removeEventListener","writeObj","stringify","createEvent","initEvent","dispatchEvent","userAgent","navigator","toLowerCase","includes","defaultTime","SIMULATE_CHANNELS","Array","from","filter","channel","forEach","METHODS","BroadcastChannelMethod","LocalStorageMethod","chooseMethod","SimulateMethod","method","find","m","useMethod","map","MessageChannel","closed","_isListening","_onMessageListener","_addEventListeners","message","internal","_unSendMessagePromises","_beforeClose","_preparePromises","_prepareChannel","_post","listenObj","_removeListenerObject","_addListenerObject","obj","awaitPrepare","then","all","_this","_state","messageChannel","sendPromise","maybePromise","s","_hasMessageListeners","length","push","listenerFn","o","LeaderElection","_channel","_options","isLeader","isDead","_isApplying","_reApply","_unloadFns","_listeners","_intervals","_duplicateListeners","_duplicateCalled","_onBeforeDie","unloadFn","die","stopCriteria","handleMessage","context","_this2","action","_sendMessage","responseTime","leaderElector","isLeaderListener","catch","success","applyOnce","_awaitLeadershipPromise","resolved","finish","clearInterval","interval","whenDeathListener","setInterval","fallbackInterval","onBeforeDie","_this3","uFn","n","msgJson","postInternal","TabManager","emitOnAllTabs","callbacks","start","reset","pause","resume","elector","_leaderElector","registry","leader","allIdle","awaitLeadership","idle","active","onIdle","onActive","isIdle","Object","values","every","v","send","isActive","some","onDuplicate","isAllIdle","setAllIdle","bool","IdleTimer","Component","props","oldDate","lastActive","lastIdle","idleTime","remaining","pageX","pageY","r","tId","eventsBound","callbackRefs","debounce","throttle","_onAction","onAction","eventsThrottle","handleEvent","_handleEvent","bind","startOnMount","startManually","_toggleIdleState","getRemainingTime","getElapsedTime","getLastActiveTime","getLastIdleTime","getTotalIdleTime","getTotalActiveTime","_setupTabManager","_bindEvents","prevProps","_unbindEvents","manager","console","error","children","crossTab","assign","element","events","passive","capture","force","setState","prevState","_this4","stopOnIdle","elapsedTimeSinceLastActive","remote","timeLeft","useIdleTimer","t","l","y","k","I","L","M","useRef","firstLoad","_timeout","emitOnIdle","emitOnActive","emitOnAction","current","intermediateOnAction","useMemo","callOnAction","nextIdle","eventsWereBound","propTypes","PropTypes","defaultProps","UseridleTimer","history","useNavigate","IdleTimerRef","ref","sessionStorage","useSelector","toggleSidebar","Sidebar","Container","fluid"],"sourceRoot":""}